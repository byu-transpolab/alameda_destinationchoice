[
["methodology.html", " 3 Methodology 3.1 Data 3.2 Model", " 3 Methodology We constructed a dataset on which to estimate park activity location choices for a sample of observed trips in Alameda County, California. Alameda County is one of the seven counties that constitutes the San Francisco Bay Area metropolitan region in California. Alameda is the seventh most populous county in California with a population of 1.5 million (???), and has 14 incorporated cities and several unincorporated communities. It is an economically and ethnically diverse county and hence it was an attractive area to use for this study. The racial makeup of Alameda County was (49.7%) White, (11.2%) African American, (1.0%) Native American, (38.7%) Asian, (1.0%) Pacific Islander, and (22.4% Hispanic or Latino (of any race). Alameda County has a diverse set of parks, ranging from local small community parks, urban and transit-accessible parks like the Lake Merritt Recreational area, accessible coastal access, and suburban recreational areas like Lake Chabot. 3.1 Data We constructed an analysis dataset from a publicly-available parks polygons layer, a commercially acquired passive device origin-destination table representing trips between the parks and home block groups, and American Community Survey data for the home block groups. We obtained a polygons shapefile layer representing open spaces in Alameda County, California from the California Protected Areas Database (???). This dataset was selected because it included multiple different types of open space including local and state parks, traditional green spaces as well as wildlife refuges and other facilities that can be used for recreation. We removed facilities that did not allow open access to the public (such as the Oakland Zoo) and facilities whose boundaries conflated with freeway right-of-way – this prevents trips through the park from being conflated with park trips in the passive origin-destination data. not_parks &lt;- c(&quot;3455&quot;, &quot;15886&quot;, &quot;13243&quot;) parks &lt;- st_read(here(&quot;data/bayarea_parks.geojson&quot;), quiet = TRUE) %&gt;% filter(COUNTY == &quot;Alameda&quot;) %&gt;% transmute( id = as.character(UNIT_ID), name = UNIT_NAME, access = factor(ACCESS_TYP, levels = c(&quot;Open Access&quot;, &quot;No Public Access&quot;, &quot;Restricted Access&quot;)), acres = ACRES, type = DES_TP) %&gt;% filter(!id %in% not_parks) %&gt;% filter(access == &quot;Open Access&quot;) %&gt;% select(id, access, acres, type) %&gt;% st_transform(this_crs) From this initial parks polygons dataset, we obtained park attribute information through OpenStreetMap (OSM) using the osmdata package for R (Padgham et al. 2017). Three attribute elements are considered in this analysis. First, we identify playgrounds using OSM facilities given a leisure = playground tag. playground_osm &lt;- opq(bb) %&gt;% # specify boundary for query add_osm_feature(key = &quot;leisure&quot;, value = &quot;playground&quot;) %&gt;% # specify which kinds of data we want osmdata_sf() %&gt;% # get a list of sf data frames for these tags trim_osmdata(bb, exclude = TRUE) playgrounds &lt;- rbind( # convert polygons to centroids playground_osm$osm_polygons %&gt;% st_transform(this_crs) %&gt;% st_centroid() %&gt;% select(osm_id), # get points playground_osm$osm_points %&gt;% st_transform(this_crs) %&gt;% select(osm_id) # no multipolygons or polylines that need to be included ) %&gt;% mutate(playground = TRUE) Second, we consider sport fields of various kinds identified with the OSM leisure = pitch tag. This tag has an additional attribute describing the sport the field is designed for, which we retain in a consolidated manner. Soccer and American football fields are considered in a single category, and baseball and softball fields are combined as well. Basketball, tennis, and volleyball courts are kept as distinct categories, with all other sport-specific fields combined into a single “other”. Golf courses are discarded. pitches_osm &lt;- opq(bb) %&gt;% # specify boundary for query add_osm_feature(key = &quot;leisure&quot;, value = &quot;pitch&quot;) %&gt;% osmdata_sf() %&gt;% trim_osmdata(bb, exclude = TRUE) pitches &lt;- rbind( # convert polygons to centroids pitches_osm$osm_polygons %&gt;% st_transform(this_crs) %&gt;% st_centroid() %&gt;% select(osm_id, sport), # get points pitches_osm$osm_points %&gt;% st_transform(this_crs) %&gt;% select(osm_id, sport) # no multipolygons or polylines that need to be included ) %&gt;% filter(sport != &quot;golf&quot;) %&gt;% mutate( sport = case_when( grepl(&quot;football&quot;, sport) | grepl(&quot;soccer&quot;, sport) ~ &quot;football / soccer&quot;, grepl(&quot;baseball&quot;, sport) | grepl(&quot;softball&quot;, sport) ~ &quot;baseball&quot;, grepl(&quot;basketball&quot;, sport) ~ &quot;basketball&quot;, grepl(&quot;tennis&quot;, sport) ~ &quot;tennis&quot;, grepl(&quot;volleyball&quot;, sport) ~ &quot;volleyball&quot;, TRUE ~ &quot;other&quot; ) ) ## Warning in st_centroid.sf(.): st_centroid assumes attributes are constant over ## geometries of x Finally, we identified trails and footpaths using the path, cycleway, and footway values of the highway tag. A visual inspection of the resulting data revealed that the large preponderance of sidewalks and cycling trails within parks in Alameda County are identified properly with these variables. trails_osm &lt;- opq(bb) %&gt;% # specify boundary for query add_osm_feature(key = &quot;highway&quot;, value = c(&quot;footway&quot;, &quot;cycleway&quot;, &quot;path&quot;)) %&gt;% osmdata_sf() %&gt;% trim_osmdata(bb, exclude = FALSE) trails &lt;- rbind( # points are nodes, so we can skip them. # lines trails_osm$osm_lines %&gt;% st_transform(this_crs) %&gt;% select(osm_id, bicycle, foot, horse), # circular paths get converted to polygons, so we need to # turn them back into lines. trails_osm$osm_polygons %&gt;% st_transform(this_crs) %&gt;% st_boundary() %&gt;% select(osm_id, bicycle, foot, horse) ) %&gt;% mutate(length = st_length(.)) It is possible for each of these facilities to exist outside the context of a public park. For example, many private apartment complexes have playgrounds and high schools will have sports facilities that are not necessarily open to the general public. We spatially matched the OSM amenities data and retained only those facilities that intersected with the CPAD open spaces database identified earlier. attributed_parks &lt;- parks %&gt;% # determine if a playground point is inside the park polygon boundary st_join(playgrounds %&gt;% select(playground), st_intersects) %&gt;% # a park with multiple playgrounds will join multiple times, so we need to # summarize them back down. group_by(id) %&gt;% slice(1) %&gt;% ungroup() %&gt;% mutate(playground = ifelse(is.na(playground), F, playground)) %&gt;% # determine if the pitch points are inside the park polygon boundaries st_join(pitches %&gt;% select(sport)) %&gt;% # multiple pitches in a park result in repeated rows. group_by(id) %&gt;% slice(1) %&gt;% ungroup() %&gt;% mutate(pitch = ifelse(is.na(sport), F, T)) %&gt;% select(-sport) %&gt;% # determine if the trails are inside the park polygon boundaries st_join(trails %&gt;% select(trail = osm_id), st_intersects) %&gt;% # multiple pitches in a park result in repeated rows. group_by(id) %&gt;% slice(1) %&gt;% ungroup() %&gt;% mutate(trail = ifelse(is.na(trail), F, T)) We provided the park boundaries layer to a commercial firm, StreetLight Data Inc., which develops and resells origin-destination matrices derived from passive device location data. The provider employs a proprietary data processing engine (called Route Science) to algorithmically transform observed device location data points (the provider uses in-vehicle GPS units and mobile device LBS) over time into contextualized, normalized, and aggregated travel patterns. From these travel patterns, the Route Science processing algorithms infer likely home Census block group locations for composite groups of people and converts raw location data points into trip origin and destination points (???; ???). park_flows &lt;- read_csv(here(&quot;data/Master_BlockGroups_Final071519.csv&quot;), col_types = cols()) %&gt;% # need to make block group id properly formatted. transmute( park = as.character(`Zone Name`), home = paste0(&quot;0&quot;, round(`Block Group ID`)), county = substr(home, 0, 5), attractions = `Zone Traffic (StL Index)`, d_share = `Percent by Home Location` ) %&gt;% # only keep bgs in the area filter(county %in% c(&quot;06001&quot;)) %&gt;% # and only keep parks that we are looking at filter(park %in% parks$id) %&gt;% mutate(flow = attractions * d_share) %&gt;% group_by(home) %&gt;% mutate( productions = sum(flow), o_share = flow / productions ) For each park polygon, the firm returned a population-weighted estimate of how many devices were observed by home location block group over several months in the period between May 2018 and October 2018. We transformed this table such that it represented the weighted unique devices traveling between block groups and parks. We discarded home location block groups outside of Alameda County; the imputed home locations can be far away from the study area for a small amount of trips and are unlikely to represent common or repeated park activities. attributed_parks &lt;- attributed_parks %&gt;% group_by(type) %&gt;% left_join(park_flows %&gt;% group_by(park) %&gt;% slice(1) %&gt;% select(park, attractions), by = c(&quot;id&quot; = &quot;park&quot;)) %&gt;% mutate(attractions = ifelse(is.na(attractions), 0, attractions)) Table presents descriptive statistics on the 500 parks assembled for this study, grouped according to the park type as defined on CPAD. A little more than half of the parks have identified paths, while around 40% of the identified parks have playgrounds and sport fields. our_summary1 &lt;- list( &quot;Acres&quot; = list(&quot;min&quot; = ~ min(.data$acres), &quot;max&quot; = ~ max(.data$acres), &quot;mean (sd)&quot; = ~ qwraps2::mean_sd(.data$acres)), &quot;Attributes&quot; = list(&quot;Has Playground&quot; = ~qwraps2::n_perc0(.data$playground), &quot;Has Pitch / Court&quot; = ~qwraps2::n_perc0(.data$pitch), &quot;Has Paths&quot; = ~qwraps2::n_perc0(.data$trail)), &quot;Visitor Devices&quot; = list(&quot;min&quot; = ~ min(.data$attractions), &quot;max&quot; = ~ max(.data$attractions), &quot;mean (sd)&quot; = ~ qwraps2::mean_sd(.data$attractions)) ) attributed_parks %&gt;% st_set_geometry(NULL) %&gt;% group_by(type) %&gt;% qwraps2::summary_table(our_summary1) %&gt;% print(markup = &quot;markdown&quot;) type: Local Park (N = 441) type: Local Recreation Area (N = 57) type: State Recreation Area (N = 2) Acres min 0.038 0.667 228.958 max 4939.817 3851.412 613.140 mean (sd) 59.81 \\(\\pm\\) 370.53 115.20 \\(\\pm\\) 509.56 421.05 \\(\\pm\\) 271.66 Attributes Has Playground 212 (48) 15 (26) 0 (0) Has Pitch / Court 161 (37) 20 (35) 0 (0) Has Paths 285 (65) 35 (61) 2 (100) Visitor Devices min 0 0 0 max 108297 29931 161 mean (sd) 1,450.03 \\(\\pm\\) 6,685.41 2,749.47 \\(\\pm\\) 6,250.42 80.50 \\(\\pm\\) 113.84 In order to understand the demographic makeup of the home block groups and potentially the characteristics of the people who make each trip, we obtained 2013-2017 five-year data aggregations from the American Community Survey using the tidycensus (???) interface to the Census API for several key demographic and built environment variables: the share of individuals by ethnic group, the share of households by income level, household median income, and the housing unit density. An important attribute of the choice model is the distance from the home block group to the park boundary. Because we have no information on where in the block group a home is actually located, we use the population-weighted block group centroid published by the Census Bureau as the location for all homes in the block group. We then measured the Euclidean distance in miles between the block group and the boundary of each park in the polygons layer. variables &lt;- c( &quot;population&quot; = &quot;B25008_001&quot;, # TOTAL POPULATION IN OCCUPIED HOUSING UNITS BY TENURE &quot;housing_units&quot; = &quot;B25001_001&quot;, # HOUSING UNITS &quot;households&quot; = &quot;B19001_001&quot;, #HOUSEHOLD INCOME IN THE PAST 12 MONTHS (IN 2017 INFLATION-ADJUSTED DOLLARS) #Estimate!!Total!!Female!!Worked in the past 12 months!!Usually worked 35 or more hours per week # RACE &quot;black&quot; = &quot;B02001_003&quot;, &quot;asian&quot; = &quot;B02001_005&quot;, &quot;pacific&quot; = &quot;B02001_006&quot;, &quot;nativeam&quot; = &quot;B02001_004&quot;, # HISPANIC OR LATINO ORIGIN BY SPECIFIC ORIGIN # The number of hispanic individuals needs to be drawn from a different table. &quot;hispanic&quot; = &quot;B03001_003&quot;, #MEDIAN HOUSEHOLD INCOME IN THE PAST 12 MONTHS (IN 2017 INFLATION-ADJUSTED DOLLARS) &quot;income&quot; = &quot;B19013_001&quot;, #HOUSEHOLD INCOME IN THE PAST 12 MONTHS (IN 2017 INFLATION-ADJUSTED DOLLARS) &quot;inc_0010&quot; = &quot;B19001_002&quot;, &quot;inc_1015&quot; = &quot;B19001_003&quot;, &quot;inc_1520&quot; = &quot;B19001_004&quot;, &quot;inc_2025&quot; = &quot;B19001_005&quot;, &quot;inc_2530&quot; = &quot;B19001_006&quot;, &quot;inc_3035&quot; = &quot;B19001_007&quot;, &quot;inc_125&quot; = &quot;B19001_015&quot;, &quot;inc_150&quot; = &quot;B19001_016&quot;, &quot;inc_200&quot; = &quot;B19001_017&quot; ) acs &lt;- get_acs(geography = &quot;block group&quot;, variables = variables, year = 2017, state = &quot;CA&quot;, county = &quot;001&quot;, geometry = TRUE) %&gt;% select(-moe) %&gt;% spread(variable, estimate) %&gt;% mutate(area = as.numeric(st_area(geometry) * 1e-6)) %&gt;% # area is in m^2, change to km^2 transmute( geoid = GEOID, population, households, housing_units, density = households / area, income, # many of the variables come in raw counts, but we want to consider # them as shares of a relevant denominator. lowincome = 100 * (inc_0010 + inc_1015 + inc_1520 + inc_2530 + inc_3035) / households, highincome = 100 * (inc_125 + inc_150 + inc_200) / households, black = 100 * black / population, asian = 100 * asian / population, other = 100 * (nativeam + pacific) / population, white_hisp = 100 - black - asian - other ) bg_centroids &lt;- read_csv( &quot;https://www2.census.gov/geo/docs/reference/cenpop2010/blkgrp/CenPop2010_Mean_BG06.txt&quot;, col_types = list(&quot;TRACTCE&quot; = col_character(), &quot;BLKGRPCE&quot; = col_character()) ) %&gt;% mutate(GEOID = str_c(STATEFP, COUNTYFP, TRACTCE, BLKGRPCE)) %&gt;% filter(COUNTYFP %in% &quot;001&quot;) %&gt;% st_as_sf(crs = 4326, coords = c(&quot;LONGITUDE&quot;, &quot;LATITUDE&quot;)) %&gt;% st_transform(this_crs) # distances from all tract centroids to all parks distances &lt;- st_distance(bg_centroids, parks, byid = TRUE) %&gt;% units::set_units(miles) %&gt;% units::drop_units() rownames(distances) &lt;- bg_centroids$GEOID colnames(distances) &lt;- parks$id distance_df &lt;- distances %&gt;% omxr::gather_matrix(value_name = &quot;dist_euclid&quot;) %&gt;% rename(home = origin, park = destination) tracts_data_index &lt;- tibble( variable = c(&quot;density&quot;, &quot;income&quot;, &quot;lowincome&quot;, &quot;highincome&quot;, &quot;black&quot;, &quot;asian&quot;, &quot;other&quot;) ) %&gt;% mutate(order = row_number()) acs %&gt;% st_set_geometry(NULL) %&gt;% filter(population &gt; 0) %&gt;% tbl_df() %&gt;% dplyr::select(tracts_data_index$variable) %&gt;% gather(variable, value) %&gt;% group_by(variable) %&gt;% summarise( `msd` = paste(median_iqr(value, na_rm = TRUE, show_n = &quot;never&quot;, digits = 1)) ) %&gt;% inner_join(tracts_data_index, by = &quot;variable&quot;) %&gt;% arrange(order) %&gt;% mutate( variable = c( &quot;Density: Households per square kilometer&quot;, &quot;Income: Median tract income&quot;, &quot;Low Income: Share of households making less than $35k&quot;, &quot;High Income: Share of households making more than $125k&quot;, &quot;Black: Share of population who is black&quot;, &quot;Asian: Share of population who is Asian&quot;, &quot;Other: Share of population who belong to other minority groups&quot;) ) %&gt;% dplyr::select(-order) %&gt;% knitr::kable(col.names = c(&quot;&quot;, &quot;Median (IQR)&quot;), booktabs = TRUE, digits = 1, caption = &quot;Descriptive Statistics for Residence Block Groups&quot;) ## Warning: `tbl_df()` is deprecated as of dplyr 1.0.0. ## Please use `tibble::as_tibble()` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. ## `summarise()` ungrouping output (override with `.groups` argument) Table 3.1: Descriptive Statistics for Residence Block Groups Median (IQR) Density: Households per square kilometer 1,352.9 (880.8, 2,187.0) Income: Median tract income 85,673.0 (58,478.0, 119,375.0) Low Income: Share of households making less than $35k 15.1 (7.8, 26.1) High Income: Share of households making more than $125k 30.4 (15.5, 46.5) Black: Share of population who is black 6.8 (1.8, 18.4) Asian: Share of population who is Asian 21.1 (10.4, 37.8) Other: Share of population who belong to other minority groups 0.5 (0.0, 1.9) 3.2 Model In random utility choice theory, if an individual living in block group \\(n\\) wishes to make a park trip, the probability that the individual will choose park \\(i\\) from the set of all parks \\(J\\) can be described as a ratio of the park’s measurable utility \\(V_{ni}\\) to the sum of the utilities for all parks in the set. In the common destination choice framework we apply a multinomial logit model (???), \\[\\begin{equation}\\label{eq:p} P_{ni} = \\frac{\\exp(V_{ni})}{\\sum_{j \\in J}\\exp(V_{nj})} \\end{equation}\\] where the measurable utility \\(V_{ni}\\) is a linear-in-parameters function of the destination attributes. If the park choice can be defined solely by its size and the impedance in reaching the park from block group \\(n\\), then the measurable utility would be \\[\\begin{equation}\\label{eq:V} V_{ni} = \\beta_{1} * \\mathit{size}_{i} + \\beta_2 * \\mathit{impedance}_{ni} \\end{equation}\\] where \\(\\beta_1, \\beta_2\\) are estimable coefficients giving the relative utility (or disutility) of that attribute to the choice maker, all else equal. It is possible to add additional amenities of the park or the journey to the utility equation. However, as the number of alternatives is large, it is impractical to consider alternative-specific constants or coefficients and therefore not possible to include attributes of the home block group or traveler \\(n\\) directly. We can, however, segment the data and estimate different distance and size parameters for different segments to observe heterogeneity in the utility parameters between different socioeconomic groups. The logarithm of the sum in the denominator of Equation (called the logsum) provides a measure of the consumer surplus of the choice set (???), \\[\\begin{equation}\\label{eq:logsum} CS_n = \\ln{{\\sum_{j \\in J}\\exp(V_{nj})}} + C \\end{equation}\\] where \\(C\\) is a constant indicating an unknown absolute value. But comparing the relative logsum values across choice makers, \\(CS_n - CS_{n-1}\\) gives an indication of which choice maker has a more valuable choice set. Or, in this case of a park destination choice model, which choice maker has better access to parks. Such a “utility-based” accessibility term is thus continuously defined, dervied directly from choice theory, and can contain multiple dimensions of the attributes of the choice (???; ???). set.seed(42) n_obs &lt;- 20000 n_alts &lt;- 10 n_flow &lt;- sum(park_flows$flow) ll0e &lt;- sum(n_obs *.8 * log(1/n_alts)) mydata &lt;- park_flows %&gt;% ungroup() %&gt;% mutate(weight = flow / sum(flow)) %&gt;% sample_n(n_obs, replace = TRUE, weight = weight) %&gt;% transmute(id = row_number(), home, alt_0 = park, validation = sample(c(TRUE,FALSE), n(), TRUE, prob = c(0.2, 0.8))) In the most typical cases, researchers estimate the utility coefficients for destination choice models from household travel surveys. As we have no knowledge of an appropriate survey on park access, we need to synthesize a suitable estimation data set. We do this by sampling 210^{4} random discrete device origin-destination pairs from the commercial passive data matrix, weighted by the volume of the flows. This corresponds to a 4.3% sample of all the observed device origin-destination pairs. The sampled origin-destination pair gives the home location as well as the “chosen” alternative for a synthetic person. In principle the individual’s choice set contains all the parks in our dataset; in practice it can be difficult to estimate choice models with so many alternatives (\\(|J| = 500\\)). For this reason we randomly sample 10 additional parks to serve as the non-chosen alternatives for our synthetic choice maker. Such random sampling of alternatives reduces the efficiency of the estimated coefficients but the coefficients remain unbiased (???). As the model has no alternative-specific constants, the standard likelihood comparison statistic against the market shares model \\(\\rho^2\\) is not computable. We instead use the likelihood comparison against the equal shares model \\(\\rho_0^2\\). sampled_parks &lt;- lapply(1:n_obs, function(i){ sample(parks$id, n_alts) }) %&gt;% unlist() %&gt;% matrix(ncol = n_alts) %&gt;% as_tibble(.name_repair = ~ str_c(&quot;alt&quot;, 1:n_alts, sep = &quot;_&quot;)) logitdata &lt;- mydata %&gt;% bind_cols(sampled_parks) %&gt;% gather(key = &quot;alt&quot;, value = &quot;park&quot;, -id, -home, -validation) %&gt;% mutate(chosen = alt == &quot;alt_0&quot;) %&gt;% arrange(id, alt) %&gt;% # append distances left_join(distance_df, by = c(&quot;home&quot;, &quot;park&quot;)) %&gt;% # append park attributes left_join(parks, by = c(&quot;park&quot; = &quot;id&quot;)) %&gt;% # append block group attributes left_join(acs %&gt;% select(geoid, density:other) %&gt;% st_set_geometry(NULL), by = c(&quot;home&quot; = &quot;geoid&quot;) ) The resulting analysis dataset therefore contains 210^{4} choice makers that select between 11 parks including the park they were observed to choose; the measured distance between the choice maker’s block group and all parks in the choice set; and the acreage of each park in the choice set. We hold out a random sample of approximately 20% of choice makers for validation purposes. We use the mlogit package for R (???, R) to estimate the multinomial logit models. References "]
]
